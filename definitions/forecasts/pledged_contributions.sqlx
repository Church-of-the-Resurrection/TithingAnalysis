config {
    type: "view",
    schema: "Forecasts",
    description: "Forecasts pledged revenue for ALL years (historical and future) based on pledge totals and seasonality. Useful for backtesting accuracy."
}

CREATE OR REPLACE VIEW
  ${self()} AS (
  WITH
    ActualPledges AS (
    SELECT
      PledgeYear,
      SUM(Amount) AS total_pledged_amount
    FROM
      ${ref("pledges")}
    GROUP BY
      1 ),
    -- Combine Actuals with the Projection
    CombinedPledges AS (
    SELECT
      PledgeYear,
      total_pledged_amount
    FROM
      ActualPledges
    UNION ALL
    SELECT
      CAST(PledgeYear as INT64),
      total_pledged_amount
    FROM
      ${ref("projected_pledge_totals")}
      -- Only include the projection if we don't have actuals for that year yet
    WHERE
      CAST(PledgeYear AS NUMERIC) NOT IN (
      SELECT
        PledgeYear
      FROM
        ActualPledges) ),
    Seasonality AS (
    SELECT
      month_num,
      seasonality_pct
    FROM
      ${ref("pledge_seasonality")} )
  SELECT
    DATE(CAST(cp.PledgeYear AS INT64), s.month_num, 1) AS forecast_month,
    '1. Pledged Revenue' AS contribution_type,
    -- Apply the same Seasonality & 98% Fulfillment logic
    CAST(cp.total_pledged_amount * 0.98 * s.seasonality_pct AS INT64) AS forecast_value,
    -- Wider confidence intervals for the projected year (90% - 110%)
    CAST(cp.total_pledged_amount * 0.90 * s.seasonality_pct AS INT64) AS prediction_interval_lower_bound,
    CAST(cp.total_pledged_amount * 1.10 * s.seasonality_pct AS INT64) AS prediction_interval_upper_bound
  FROM
    CombinedPledges cp
  CROSS JOIN
    Seasonality s
  ORDER BY
    1 )
